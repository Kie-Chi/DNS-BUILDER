from typing import Dict
import re

from numpy import dstack

from ..abstractions import Includer
from ..io import DNSBPath
from ..datacls import Pair
from ..exceptions import ConfigurationError, DNSBPathNotFoundError
from .. import constants

# -------------------------
#
#   BIND IMPLEMENTATIONS
#
# -------------------------

class BindIncluder(Includer):
    """
        Class describe the `include "config-file";` line for BIND
    """
    _tmpl = '\n# Auto Generated by DNS-Builder\ninclude "{config_line}";\n'
    _blk = '\n# Auto Generated by DNS-Builder\n{block} {{{lines}}};\n'
    _global_blk = '\n# Auto Generated by DNS-Builder{lines}\n'

    def _make_blk(self, pair: Pair):
        block = self.parse_blk(pair)
        main_conf = self.confs.get("global", None)
        if main_conf is None:
            raise DNSBPathNotFoundError("global conf not found")
        line = self._tmpl.format(config_line=pair.dst)
        content = self._blk.format(block=block, lines=line)
        self.fs.append_text(main_conf.src, content)
        self.confs[block] = pair.src

    def include(self, pair: Pair):
        block = self.parse_blk(pair)
        if block is None:
            block = "global"
        conf = self.confs.get(block, None)
        if conf is None:
            self._make_blk(pair)
            return
        content = self._tmpl.format(config_line=pair.dst)
        self.fs.append_text(conf.src, content)
        return None

    def contain(self):
        _all = set(self.confs.keys())
        def _append(match: re.Match):
            blk_name = match.group(1)
            lines = match.group(2)
            if blk_name in _all:
                _all.remove(blk_name)
                updated_lines = lines + "\n" + self._tmpl.format(config_line=self.confs[blk_name].dst)
                return f"{blk_name} {{{updated_lines}\n}};"
            return f"{blk_name} {{{lines}}};"
        pattern = re.compile(r"(\w+)\s*\{(.*)\};", re.DOTALL)
        origin = self.fs.read_text(self.confs["global"].src)
        origin = pattern.sub(_append, origin)
        if _all:
            for blk in _all:
                if blk == 'global':
                    continue
                origin += self._blk.format(block=blk, lines=self._tmpl.format(config_line=self.confs[blk].dst))
        self.fs.write_text(self.confs["global"].src, origin)

# -------------------------
#
#   UNBOUND IMPLEMENTATIONS
#
# -------------------------

class UnboundIncluder(Includer):
    """
        Class describe the `include: config-file` line for Unbound
    """
    _tmpl = '\n# Auto Generated by DNS-Builder\ninclude: "{config_line}"\n'

    def _make_blk_ctx(self, pair: Pair, block_name: str):
        """
        Create block content with proper block identifier for Unbound.
        """
        if block_name == "global":
            return f'\n# Auto-Include by DNS Builder\n{self._tmpl.format(config_line=pair.dst)}'
        else:
            # For block configs, add the block identifier
            return f'\n# Auto-Include {block_name} block by DNS Builder\n{block_name}:\n{self._tmpl.format(config_line=pair.dst)}'

    def include(self, pair: Pair):
        """
        Add include directive to the appropriate configuration file.
        """
        block = self.parse_blk(pair)
        if block is None:
            block = "global"
        
        # Get the target configuration file
        conf = self.confs.get(block, None)
        if conf is None:
            # If no specific block config exists, use global config
            conf = self.confs.get("global", None)
            if conf is None:
                raise DNSBPathNotFoundError("global conf not found")
        
        # Add include directive with proper block formatting
        content = self._make_blk_ctx(pair, block)   
        self.fs.append_text(conf.src, content)
        return None

    def contain(self):
        global_conf = self.confs.get("global", None)
        if global_conf is None:
            return
        
        # Add include directives for all block configs to the global config
        for block_name, pair in self.confs.items():
            if block_name != "global":
                content = self._make_blk_ctx(pair, block_name)
                self.fs.append_text(global_conf.src, content)


# -------------------------
#
#   PDNS RECURSOR IMPLEMENTATIONS
#
# -------------------------

class PdnsRecursorIncluder(Includer):

    _tmpl = '\n# include {config_line}'
    _write = "\n# Auto Generated by DNS Builder\ninclude-dir={include_dir}\n"
    
    def include(self, pair: Pair):
        """
        include a config-file, moving to INCLUDE_DIR
        """
        block = self.parse_blk(pair)
        if block is None:
            block = "global"

        # only a comment, then change it
        file_name = pair.src.__rname__
        i_dir = f"/usr/local/etc/{constants.INCLUDE_SUBDIR}"
        new_dst = DNSBPath(f"{i_dir}/{file_name}")
        _comment = f"{pair.dst} -> {new_dst}"
        origin = self.fs.read_text(self.confs[block].src)
        pattern = re.compile(r"^\s*include-dir\s*=\s*(.*)", re.IGNORECASE)
        _fnd_icld_dir = []
        for line in origin.splitlines():
            match = pattern.match(line)
            if match:
                _fnd_icld_dir.append(match.group(1))

        write = ""
        if not _fnd_icld_dir:
            write += self._write.format(include_dir=i_dir)
        else:
            if len(_fnd_icld_dir) > 1:
                raise ConfigurationError("Multiple include-dir found")
            if _fnd_icld_dir[0] != i_dir:
                raise ConfigurationError(f"include-dir not match, expected: {i_dir}, actual: {_fnd_icld_dir[0]}")
        write += self._tmpl.format(config_line=_comment)
        self.fs.append_text(self.confs[block].src, write)
        return pair._replace(dst=new_dst)        
        

    def contain(self):
        """
        Only global main conf, nothing to contain
        """
        pass


class KnotResolverIncluder(Includer):
    _tmpl = "\n-- Auto Generated by DNS Builder\ndofile('{config_line}')\n"

    def include(self, pair: Pair):
        block = self.parse_blk(pair)
        if block is None:
            block = "global"
        conf = self.confs.get(block, None)
        if conf is None:
            conf = self.confs.get("global", None)
            if conf is None:
                raise DNSBPathNotFoundError("global conf not found")
        content = self._tmpl.format(config_line=pair.dst)
        self.fs.append_text(conf.src, content)
        return None

    def contain(self):
        pass

class KnotResolver6Includer(KnotResolverIncluder):
    pass

# Dynamically generate __all__
from ..utils.reflection import gen_exports

__all__ = gen_exports(
    ns=globals(),
    base_path='dnsbuilder.bases.includers',
    patterns=['Includer']
)
