# images.py
import os
from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Any, Set
import copy
import logging

logger = logging.getLogger(__name__)

# ... (BIND_DOCKERFILE_TEMPLATE remains the same) ...
BIND_DOCKERFILE_TEMPLATE = """
# Dockerfile for {name} (BIND v{version})
# Auto-generated by DNS Builder

# The base image is now configurable by the Image class
FROM {base_image}

ENV DEBIAN_FRONTEND=noninteractive

# --- STAGE 1: Install Build Dependencies ---
# These packages are required to compile the software. They change infrequently.
RUN apt-get update && apt-get install -y --no-install-recommends {dep_packages}

# --- STAGE 2: Download and Compile Source ---
WORKDIR /usr/src
RUN wget --no-check-certificate https://downloads.isc.org/isc/bind9/{version}/bind-{version}.tar.xz && \\
    tar -xvf bind-{version}.tar.xz

WORKDIR /usr/src/bind-{version}
RUN ./configure --prefix=/usr/local --sysconfdir=/usr/local/etc --localstatedir=/usr/local/var && \\
    make -j$(nproc) && \\
    make install

# --- STAGE 3: Final Configuration ---
# Set up the environment, user, and permissions for the final image.
ENV LD_LIBRARY_PATH=/usr/local/lib/:$LD_LIBRARY_PATH

RUN groupadd -r named && useradd -r -g named named
RUN mkdir -p /usr/local/var/named && \\
    mkdir -p /var/cache/named && \\
    mkdir -p /usr/local/var/run/named && \\
    chown -R named:named /usr/local/var/run/named && \\
    chown -R named:named /var/cache/named && \\
    chown -R named:named /usr/local/var/named && \\
    chown -R named:named /usr/local/etc

RUN touch /usr/local/etc/named.conf && \\
    chown named:named /usr/local/etc/named.conf

# --- STAGE 4: Install Runtime Utilities ---
# This is the LAST installation step. If a user only changes the 'util' list,
# Docker will use the cache for all previous stages, resulting in a very fast rebuild.
RUN apt-get update && apt-get install -y --no-install-recommends {util_packages} && \\
    rm -rf /var/lib/apt/lists/*

# Expose standard DNS ports
EXPOSE 53/tcp
EXPOSE 53/udp

# Set default user
USER named

# Define default command
CMD ["/usr/local/sbin/named", "-g", "-c", "/usr/local/etc/named.conf"]
"""

class Image(ABC):
    # ... (rest of the class is the same) ...
    def __init__(self, config: Dict[str, Any]):
        self.name: str = config['name']
        self.ref: Optional[str] = config.get('ref')
        self.software: Optional[str] = config.get('software')
        self.version: Optional[str] = config.get('version')
        self.util: List[str] = config.get('util', [])
        self.dependency: List[str] = config.get('dependency', [])

    def write(self, directory: str):
        if not self.software or not self.version:
            logger.debug(f"Image '{self.name}' is not buildable (it's likely an alias), skipping Dockerfile generation.")
            return
        content = self._generate_dockerfile_content()
        dockerfile_path = os.path.join(directory, "Dockerfile")
        with open(dockerfile_path, "w") as f:
            f.write(content)
        logger.info(f"Dockerfile for '{self.name}' written to {dockerfile_path}")

    def _generate_dockerfile_content(self) -> str:
        return ""

class BindImage(Image):
    # ... (rest of the class is the same) ...
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        
        self.base_image = 'ubuntu:20.04'

        default_deps = {'build-essential', 'pkg-config', 'wget', 'xz-utils', 'libssl-dev', 'libperl-dev', 'libcap-dev', 'libuv1-dev', 'libnghttp2-dev'}
        default_utils = {'vim', 'dnsutils', 'tcpdump', 'tmux'}
        logger.debug(f"[{self.name}] Initializing BindImage with default deps: {default_deps} and utils: {default_utils}")

        self.dependency = sorted(list(default_deps.union(set(self.dependency))))
        self.util = sorted(list(default_utils.union(set(self.util))))
        logger.debug(f"[{self.name}] Final merged dependencies: {self.dependency}")
        logger.debug(f"[{self.name}] Final merged utilities: {self.util}")

    def _generate_dockerfile_content(self) -> str:
        dep_packages = " ".join(self.dependency)
        util_packages = " ".join(self.util)
        if not util_packages:
            util_packages = "''"
        
        logger.debug(f"[{self.name}] Generating Dockerfile content with version={self.version}, base_image={self.base_image}")
        return BIND_DOCKERFILE_TEMPLATE.format(name=self.name, version=self.version, base_image=self.base_image, dep_packages=dep_packages, util_packages=util_packages)

def _instantiate_from_config(config: Dict[str, Any]) -> Image:
    """Helper function to create a concrete Image instance from a resolved config."""
    software_type = config.get('software')
    logger.debug(f"Instantiating image '{config['name']}' of software type '{software_type}'.")
    if software_type == "bind":
        return BindImage(config)
    if software_type is None:
        return Image(config)
    raise ValueError(f"Image '{config['name']}' has an unknown 'software' type: {software_type}")

class ImageFactory:
    """
    Resolves image inheritance and creates final, materialized Image objects.
    """
    def __init__(self, images_config: List[Dict[str, Any]]):
        self.configs = {conf['name']: conf for conf in images_config}
        self.resolved_images: Dict[str, Image] = {}
        self.resolving_stack: Set[str] = set()
        logger.debug("ImageFactory initialized.")

    def create_all(self) -> Dict[str, Image]:
        """Creates all defined images, resolving their references."""
        logger.info("Resolving and creating all defined images...")
        for name in self.configs:
            if name not in self.resolved_images:
                self._resolve(name)
        logger.info(f"All {len(self.resolved_images)} images created successfully.")
        return self.resolved_images

    def _resolve(self, name: str) -> Image:
        """Recursively resolves an image and its parents, returning the final object."""
        if name in self.resolved_images:
            logger.debug(f"Image '{name}' already resolved (memoization hit).")
            return self.resolved_images[name]

        if name in self.resolving_stack:
            # This is a safeguard; Config validation should catch it first.
            raise ValueError(f"Internal error: Circular dependency detected involving '{name}'")
        
        logger.debug(f"Resolving image '{name}'...")
        self.resolving_stack.add(name)
        config = self.configs[name]
        ref = config.get('ref')

        if not ref:
            logger.debug(f"Image '{name}' is a base image. Instantiating directly.")
            final_image = _instantiate_from_config(config)
        else:
            if ':' in ref:
                logger.debug(f"Image '{name}' references a pre-defined software: '{ref}'.")
                sw, version = ref.split(':', 1)
                parent_config = {'name': ref, 'software': sw, 'version': version}
                parent_image = _instantiate_from_config(parent_config)
            else:
                logger.debug(f"Image '{name}' references another image: '{ref}'. Resolving parent first.")
                parent_image = self._resolve(ref)

            merged_config = self._merge(parent_image, config)
            final_image = _instantiate_from_config(merged_config)

        self.resolving_stack.remove(name)
        self.resolved_images[name] = final_image
        logger.debug(f"Successfully resolved and cached image '{name}'.")
        return final_image

    def _merge(self, parent: Image, child_config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Merges a parent Image object's attributes with a child's config dict.
        Child's config takes precedence. Lists are merged (union).
        """
        logger.debug(f"Merging parent '{parent.name}' into child '{child_config['name']}'.")
        merged = {
            'name': child_config['name'], 'ref': child_config.get('ref'),
            'software': parent.software, 'version': parent.version,
            'dependency': copy.deepcopy(parent.dependency), 'util': copy.deepcopy(parent.util)
        }

        merged['software'] = child_config.get('software', merged['software'])
        merged['version'] = child_config.get('version', merged['version'])
        
        child_deps = set(child_config.get('dependency', []))
        child_utils = set(child_config.get('util', []))
        
        merged['dependency'] = sorted(list(set(merged['dependency']).union(child_deps)))
        merged['util'] = sorted(list(set(merged['util']).union(child_utils)))
        logger.debug(f"Merge result for '{child_config['name']}': {merged}")
        return merged